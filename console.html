<html>
<head>
<style>



</style>
</head>
<body>


<div class=''>


<script>
(function(){
  
  window.addEventListener('load', Init);
  
  function Init(){
    RunTests();
  }
  function RunTests(){
    TestBus();
    console.log('---------');
    TestIncrementUnit();
    console.log('---------');
    TestRegister();
    console.log('---------');
    TestRAM();
    console.log('---------');
    TestArithmeticLogicUnit();
  }
  
})();


function Bus(){
  var self = this;
  var undefined;
  
  
  var wires = [];
  
  
  self.get = Get;
  self.connect = Connect;
  
  
  function Get(index){
    if(index < 0 || index >= wires.length)
      throw 'Bus index out of range';
    return wires[index];
  }
  function Connect(pins){
    if(pins.length != wires.length)
      throw 'Desired connections do not match wires. Too many or too few';
    
    for(var i=0; i<wires.length; i++){
      var wire = wires[i];
      var pin = pins[i];
      pin(wire);
    }
  }
  
  
  (function Constructor(refBitSize){
    if(refBitSize === undefined)
      throw 'refBitSize required for Register initialization';
    
    for(var i=0; i<refBitSize; i++)
      wires.push(new Wire());
  }).apply(self, arguments);
}
function TestBus(){
  var reg1 = new Register(4);
  var reg2 = new Register(4);
  var bus  = new Bus(4);
  
  var r1out0 = new Wire();
  var r1out1 = new Wire();
  var r1out2 = new Wire();
  var r1out3 = new Wire();
  
  var wenable = new Wire();
  var wset = new Wire();
  
  reg1.IN0(r1out0);
  reg1.IN1(r1out1);
  reg1.IN2(r1out2);
  reg1.IN3(r1out3);
  
  reg1.ENABLE(wenable);
  reg1.SET(wset);
  
  bus.connect([reg1.OUT0, reg1.OUT1, reg1.OUT2, reg1.OUT3]);
  bus.connect([reg2.IN0, reg2.IN1, reg2.IN2, reg2.IN3]);
  
  console.log('reg1', reg1.repr());
  console.log('reg2', reg2.repr());
  
  r1out0.on(window);
  r1out2.on(window);
  r1out3.on(window);
  wenable.on(window);
  wset.on(window);
  
  console.log('reg1', reg1.repr());
  console.log('reg2', reg2.repr());
}

function PinGroup(){
  var self = this;
  var undefined;
  
  
  var pins = {}
  var device;
  
  
  self.write = Write;
  self.read = Read;
  self.init = Init;
  
  self.list = List;
  self.repr = Repr;
  self.print = Print;
  
  
  function Write(label, value){
    if(label === undefined) throw 'PinGroup Write requires label';
    value = parseInt(value);
    
    ThrowExists(label);
    var old = pins[label].status();
    
    if (value > 0) pins[label].on(device);
    else pins[label].off(device);
    
    return old;
  }
  function Read(label){
    if(label === undefined) throw 'PinGroup Read requires label';
    
    ThrowExists(label);
    return pins[label].status();
  }
  function Init(label, listener){
    if(listener === undefined) throw 'PinGroup Init requires listener';
    if(label === undefined) throw 'PinGroup Init requires label';
    
    pins[label] = new Wire();
  
    return function SetPin(obj){
      if(obj instanceof Wire) return ConnectWire(obj);
      else if(typeof obj === 'function') return ConnectPin(obj);
      throw 'Unknown obj tried to connected to pin';
    }
    
    function ConnectWire(wire){
      pins[label].unlisten(listener);
      pins[label] = wire;
      pins[label].listen(listener);
      listener();
    }
    function ConnectPin(pin){
      var wire = new Wire();
      pin(wire);
      ConnectWire(wire);
    }
  }
  
  function List(){
    var list = [];
    
    for(var pin in pins)
      list.push(pin);
    
    return list;
  }
  function Repr(){
    var output = [];
    
    for(var pin in pins){
      var value = pins[pin].status();
      output.push('PIN '+pin+' = '+value);
    }
    
    output.sort();
    return output.join('\n');
  }
  function Print(){
    console.groupCollapsed('PIN Group');
    
    var lines = Repr().split('\n');
    for(var i=0; i<lines.length; i++){
      var line = lines[i];
      console.log(line);
    }
    
    console.groupEnd();
  }
  
  
  function ThrowExists(label){
    if(Exists(label)) return true;
    throw 'PIN \''+label+'\' does not exists on device.';
  }
  function Exists(label){
    return pins[label] !== undefined;
  }
  
  
  (function Constructor(_device){
    if(_device === undefined)
      throw 'Device required for PinGroup initialization.';
    device = _device;
  }).apply(self, arguments);
}
function BinaryPinGroup(){
  var self = this;
  var undefined;
  
  
  var pinGroup;
  var pins;
  
  
  self.pins = Pins;
  
  self.read = Read;
  self.write = Write;
  
  
  function Pins(){
    return pins;
  }
  function Read(){
    var groupValue = 0;
    
    for(var i=0; i<pins.length; i++){
      var pin = pins[i];
      var pinValue = pinGroup.read(pin);
      groupValue |= pinValue << i;
    }
    
    return groupValue;
  }
  // returns bool (true if overflow)
  function Write(value){
    if (value === undefined || typeof value != 'number' || value % 1 != 0 || value < 0)
      throw 'BinaryPinGroup Write method requires a positive integer value';
    
    for(var i=0; i<pins.length; i++){
      var pin = pins[i];
      var pinValue = value & (1 << i);
      pinGroup.write(pin, pinValue);
    }
    
    return value >= (1 << pins.length);
  }
  
  
  (function Constructor(_pinGroup, _pins){
    if(_pinGroup === undefined)
      throw 'PinGroup required for BinaryPinGroup initialization.';
    if(_pins === undefined)
      throw 'Pins Array required for BinaryPinGroup initialization.';
    
    pinGroup = _pinGroup;
    pins = _pins;
  }).apply(self, arguments);
}

function IncrementUnit(){
  var self = this;
  var undefined;
  
  
  var pins = new PinGroup(self);
  var inputGroup;
  var outputGroup;
  
  
  self.repr = Repr;
  
  
  function Repr(){
    var input = inputGroup.read();
    var output = outputGroup.read();
    return 'IncrementUnit(in: '+input+'; out: '+output+')';
  }
  
  
  function Update(){
    outputGroup.write(inputGroup.read() + 1);
  }
  
  
  (function Constructor(refBitSize){
    if(refBitSize === undefined)
      throw 'refBitSize required for Register initialization';
    
    inputGroup = [];
    outputGroup = [];
    
    for(var i=0; i<refBitSize; i++){
      self['IN'+i] = pins.init('IN'+i, Update);
      self['OUT'+i] = pins.init('OUT'+i, Update);
      inputGroup.push('IN'+i);
      outputGroup.push('OUT'+i);
    }
    
    inputGroup = new BinaryPinGroup(pins, inputGroup);
    outputGroup = new BinaryPinGroup(pins, outputGroup);
    
    Update();
  }).apply(self, arguments);
}
function TestIncrementUnit(){
  var inc = new IncrementUnit(4);
  
  var in0 = new Wire();
  var in1 = new Wire();
  var in2 = new Wire();
  var in3 = new Wire();
  
  var out0 = new Wire();
  var out1 = new Wire();
  var out2 = new Wire();
  var out3 = new Wire();
  
  inc.IN0(in0);
  inc.IN1(in1);
  inc.IN2(in2);
  inc.IN3(in3);
  
  inc.OUT0(out0);
  inc.OUT1(out1);
  inc.OUT2(out2);
  inc.OUT3(out3);
  
  console.log(inc.repr());
  
  in0.on(window);
  in3.on(window);
  
  console.log(inc.repr());
  
  in1.on(window);
  in2.on(window);
  
  console.log(inc.repr());
}

function Register(){
  var self = this;
  var undefined;
  
  
  var savedValue = 0;
  
  var pins = new PinGroup(self);
  var inputGroup;
  var outputGroup;
  
  
  self.SET = pins.init('SET', Update);
  self.ENABLE = pins.init('ENABLE', Update);
  
  self.repr = Repr;
  
  
  function Repr(){
    var input = inputGroup.read();
    var output = outputGroup.read();
    var saved = savedValue;
    return 'Register(in: '+input+'; out: '+output+'; saved: '+saved+')';
  }
  
  
  function Update(){
    if(pins.read('SET'))
      DoSetValue();
    if(pins.read('ENABLE'))
      DoEnableValue();
    else
      DoClearValue();
  }
  function DoSetValue(){
    savedValue = inputGroup.read();
  }
  function DoEnableValue(){
    outputGroup.write(savedValue);
  }
  function DoClearValue(){
    outputGroup.write(0);
  }
  
  
  (function Constructor(refBitSize){
    if(refBitSize === undefined)
      throw 'refBitSize required for Register initialization';
    
    inputGroup = [];
    outputGroup = [];
    
    for(var i=0; i<refBitSize; i++){
      self['IN'+i] = pins.init('IN'+i, Update);
      self['OUT'+i] = pins.init('OUT'+i, Update);
      inputGroup.push('IN'+i);
      outputGroup.push('OUT'+i);
    }
    
    inputGroup = new BinaryPinGroup(pins, inputGroup);
    outputGroup = new BinaryPinGroup(pins, outputGroup);
  }).apply(self, arguments);
}
function TestRegister(){
  var register = new Register(4);
  
  var in0 = new Wire();
  var in1 = new Wire();
  var in2 = new Wire();
  var in3 = new Wire();
  
  var out0 = new Wire();
  var out1 = new Wire();
  var out2 = new Wire();
  var out3 = new Wire();
  
  var wset = new Wire();
  var wenable = new Wire();
  
  register.IN0(in0);
  register.IN1(in1);
  register.IN2(in2);
  register.IN3(in3);
  
  register.OUT0(out0);
  register.OUT1(out1);
  register.OUT2(out2);
  register.OUT3(out3);
  
  register.SET(wset);
  register.ENABLE(wenable);
  
  // in: 0000; out: 0000; saved: 0000
  console.log(register.repr());
  
  in0.on(window);
  in2.on(window);
  
  // in: 1010; out: 0000; saved: 0000
  console.log(register.repr());
  
  wenable.on(window);
  
  // in: 1010; out: 0000; saved: 0000
  console.log(register.repr());
  
  wset.on(window);
  
  // in: 1010; out: 1010; saved: 1010
  console.log(register.repr());
  
  wset.off(window);
  in0.off(window);
  in3.on(window);
  
  // in: 0011; out: 1010; saved: 1010
  console.log(register.repr());
  
  wenable.off(window);
  
  // in: 0011; out: 0000; saved: 1010
  console.log(register.repr());
}

function RAM(){
  var self = this;
  var undefined;
  
  
  var mem = {};
  
  var pins = new PinGroup(self);
  var inputGroup;
  var outputGroup;
  
  
  self.SET = pins.init('SET', Update);
  self.ENABLE = pins.init('ENABLE', Update);
  
  self.repr = Repr;
  
  
  function Repr(){
    return 'RAM(in: '+inputGroup.read()+'; out: '+outputGroup.read()+')';
  }
  
  
  function Update(){
    if(pins.read('SET'))
      DoSet();
    else if(pins.read('ENABLE'))
      DoEnable();
  }
  function DoEnable(){
    var savedValue = mem[inputGroup.read()];
    if (savedValue === undefined)
      savedValue = 0;
    
    outputGroup.write(savedValue);
  }
  function DoSet(){
    mem[inputGroup.read()] = outputGroup.read();
  }
  function DoClearValue(){
    outputGroup.write(0);
  }
  
  
  (function Constructor(refBitSize){
    if(refBitSize === undefined)
      throw 'refBitSize required for Register initialization';
    
    inputGroup = [];
    outputGroup = [];
    
    for(var i=0; i<refBitSize; i++){
      self['IN'+i] = pins.init('IN'+i, Update);
      self['OUT'+i] = pins.init('OUT'+i, Update);
      inputGroup.push('IN'+i);
      outputGroup.push('OUT'+i);
    }
    
    inputGroup = new BinaryPinGroup(pins, inputGroup);
    outputGroup = new BinaryPinGroup(pins, outputGroup);
  }).apply(self, arguments);
}
function TestRAM(){
  var ram = new RAM(4);
  
  var in0 = new Wire();
  var in1 = new Wire();
  var in2 = new Wire();
  var in3 = new Wire();
  
  var out0 = new Wire();
  var out1 = new Wire();
  var out2 = new Wire();
  var out3 = new Wire();
  
  var wset = new Wire();
  var wenable = new Wire();
  
  ram.IN0(in0);
  ram.IN1(in1);
  ram.IN2(in2);
  ram.IN3(in3);
  
  ram.OUT0(out0);
  ram.OUT1(out1);
  ram.OUT2(out2);
  ram.OUT3(out3);
  
  ram.SET(wset);
  ram.ENABLE(wenable);
  
  // in: 0000; out: 0000
  console.log(ram.repr());
  
  in0.on(window);
  in2.on(window);
  wenable.on(window);
  
  // in: 1010; out: 0000
  console.log(ram.repr());
  
  out0.on(window);
  out1.on(window);
  out2.on(window);
  
  // in: 1010; out: 1110
  console.log(ram.repr());
  
  wset.on(window);
  wset.off(window);
  
  out0.off(window);
  out1.off(window);
  out2.off(window);
  
  // in: 1010; out: 1110
  console.log(ram.repr());
  
  in3.on(window);
  
  // in: 1010; out: 0000
  console.log(ram.repr());
  
  in3.off(window);
  
  // in: 1010; out: 1110
  console.log(ram.repr());
}

function ArithmeticLogicUnit(){
  var self = this;
  
  
  var refBitSize;
  var pins = new PinGroup(self);
  var inputA, inputB, output;
  // controlPins will be replaced with a BinaryPinGroup
  var controlPins = ['CTL0', 'CTL1', 'CTL2', 'CTL3'];
  
  
  self.FLAG0 = pins.init('FLAG0', Update);
  self.FLAG1 = pins.init('FLAG1', Update);
  self.FLAG2 = pins.init('FLAG2', Update);
  self.FLAG3 = pins.init('FLAG3', Update);
  self.FLAG4 = pins.init('FLAG4', Update);
  self.FLAG5 = pins.init('FLAG5', Update);
  
  
  self.repr = Repr;
  
  
  function Repr(){
    return 'ALU(A: '+inputA.read()+'; B: '+inputB.read()+'; OUT: '+output.read()+'; F0: '+pins.read('FLAG0')+'; F1: '+pins.read('FLAG1')+'; F2: '+pins.read('FLAG2')+'; F3: '+pins.read('FLAG3')+'; F4: '+pins.read('FLAG4')+'; F5: '+pins.read('FLAG5')+'; CTL: '+controlPins.read()+')';
  }
  
  
  function Update(){
    ClearFlags();
    
    switch(controlPins.read()){
      case  0: DoAdd(); break;
      case  1: DoSub(); break;
      case  2: DoMul(); break;
      case  3: DoDiv(); break;
      case  4: DoMod(); break;
      case  5: DoCMP(); break;
      case  6: DoLShift(); break;
      case  7: DoRShift(); break;
      case  8: DoAnd(); break;
      case  9: DoOr(); break;
      case 10: DoNot(); break;
      case 11: DoXor(); break;
      case 12: DoAccPass(); break;
      case 13: DoTMPPass(); break;
      case 14: break;
      case 15: break;
    }
    
    CalculateIndependentFlags();
  }
  function ClearFlags(){
    pins.write('FLAG0', 0);
    pins.write('FLAG1', 0);
    pins.write('FLAG2', 0);
    pins.write('FLAG3', 0);
    pins.write('FLAG4', 0);
    pins.write('FLAG5', 0);
  }
  function CalculateIndependentFlags(){
    var A = inputA.read();
    var B = inputB.read();
    var O = output.read();
    
    if (O === 0) pins.write('FLAG1', 1);
    if (A  >  B) pins.write('FLAG5', 1);
    if (A === B) pins.write('FLAG4', 1);
  }
  function WriteOutput(out){
    if (output.write(out))
      pins.write('FLAG0', 1);
  }
  
  function DoAdd(){
    var A = inputA.read();
    var B = inputB.read();
    var out = A + B;
    
    WriteOutput(out);
  }
  function DoSub(){
    var A = inputA.read();
    var B = inputB.read();
    var out = Math.abs(A - B);
    
    if (A - B < 0) pins.write('FLAG2', 1);
    
    WriteOutput(out);
  }
  function DoMul(){
    var A = inputA.read();
    var B = inputB.read();
    var out = A * B;
    
    WriteOutput(out);
  }
  function DoDiv(){
    var A = inputA.read();
    var B = inputB.read();
    
    if (B === 0){
      output.write(0);
      pins.write('FLAG3', 1);
      return;
    }
    
    var out = Math.floor(A / B);
    WriteOutput(out);
  }
  function DoMod(){
    var A = inputA.read();
    var B = inputB.read();
    var out = A % B;
    
    WriteOutput(out);
  }
  function DoCMP(){
    output.write(0);
  }
  function DoLShift(){
    var A = inputA.read();
    var B = inputB.read();
    var out = A << B;
    
    WriteOutput(out);
  }
  function DoRShift(){
    var A = inputA.read();
    var B = inputB.read();
    var out = A >> B;
    
    WriteOutput(out);
  }
  function DoAnd(){
    var A = inputA.read();
    var B = inputB.read();
    var out = A & B;
    
    WriteOutput(out);
  }
  function DoOr(){
    var A = inputA.read();
    var B = inputB.read();
    var out = A | B;
    
    WriteOutput(out);
  }
  function DoNot(){
    var A = inputA.read();
    var filled = (1 << refBitSize) - 1;
    var out = A ^ filled;
    
    WriteOutput(out);
  }
  function DoXor(){
    var A = inputA.read();
    var B = inputB.read();
    var out = A ^ B;
    
    WriteOutput(out);
  }
  function DoAccPass(){
    var A = inputA.read();
    WriteOutput(A);
  }
  function DoTMPPass(){
    var B = inputB.read();
    WriteOutput(B);
  }
  
  
  (function Constructor(_refBitSize){
    if(_refBitSize === undefined)
      throw 'refBitSize required for ALU initialization';
    
    refBitSize = _refBitSize;
    
    inputA = [];
    inputB = [];
    output = []
    
    for(var i=0; i<refBitSize; i++){
      self['A'+i] = pins.init('A'+i, Update);
      self['B'+i] = pins.init('B'+i, Update);
      self['OUT'+i] = pins.init('OUT'+i, Update);
      inputA.push('A'+i);
      inputB.push('B'+i);
      output.push('OUT'+i);
    }
    
    inputA = new BinaryPinGroup(pins, inputA);
    inputB = new BinaryPinGroup(pins, inputB);
    output = new BinaryPinGroup(pins, output);
    
    for(var i=0,controlPin; controlPin=controlPins[i++];)
      self[controlPin] = pins.init(controlPin, Update);
    controlPins = new BinaryPinGroup(pins, controlPins);
    
    Update();
  }).apply(self, arguments);
}
function TestArithmeticLogicUnit(){
  var alu = new ArithmeticLogicUnit(3);
  
  var ref = [];
  var pins = new PinGroup(ref);
  
  pins.init('A0', new Function())(alu.A0);
  pins.init('A1', new Function())(alu.A1);
  pins.init('A2', new Function())(alu.A2);
  
  pins.init('B0', new Function())(alu.B0);
  pins.init('B1', new Function())(alu.B1);
  pins.init('B2', new Function())(alu.B2);
  
  pins.init('C0', new Function())(alu.CTL0);
  pins.init('C1', new Function())(alu.CTL1);
  pins.init('C2', new Function())(alu.CTL2);
  pins.init('C3', new Function())(alu.CTL3);
  
  var A = new BinaryPinGroup(pins, ['A0', 'A1', 'A2']);
  var B = new BinaryPinGroup(pins, ['B0', 'B1', 'B2']);
  var CTL = new BinaryPinGroup(pins, ['C0', 'C1', 'C2', 'C3']);
  
  console.log(alu.repr());
  
  CTL.write(3);
  A.write(5);
  B.write(2);
  
  console.log(alu.repr());
  
  CTL.write(8);
  B.write(3);
  
  console.log(alu.repr());
  
  CTL.write(13);
  
  console.log(alu.repr());
}

function Wire(){
  var self = this;
  
  
  var stat = [];
  var listeners = [];
  
  
  self.on = On;
  self.off = Off;
  self.status = Status;
  
  self.listen = Listen;
  self.unlisten = Unlisten;
  
  
  function On(parent){
    if(stat.indexOf(parent) !== -1)
      return;
    var oldStatus = Status();
    stat.push(parent);
    if (oldStatus != Status())
      PropogateChange();
  }
  function Off(parent){
    var index = stat.indexOf(parent);
    if(index === -1)
      return;
    var oldStatus = Status();
    stat.splice(index, 1);
    if (oldStatus != Status())
      PropogateChange();
  }
  function Status(){
    return stat.length > 0 ? 1 : 0;
  }
  
  function Listen(funct){
    if(listeners.indexOf(funct) !== -1) return;
    listeners.push(funct);
  }
  function Unlisten(funct){
    var index = listeners.indexOf(funct);
    if(index === -1) return;
    listeners.splice(index, 1);
  }
  function PropogateChange(){
    for(var i=0; i<listeners.length; i++)
      listeners[i]();
  }
  
  
  (function Constructor(){}).apply(self, arguments);
}


</script>
<body>
</html>